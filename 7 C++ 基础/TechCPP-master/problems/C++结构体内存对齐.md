C++中的结构体内存对齐是为了提高内存访问效率而采用的一种内存布局优化方式。在结构体中，根据处理器的架构和编译器设定的规则，可能会自动插入填充字节（padding），以确保结构体的成员变量按照一定的对齐方式存储。

以下是结构体内存对齐的基本原则：

1. 结构体的起始地址能够被其最宽基本类型成员的大小所整除。
2. 结构体中每个成员相对于结构体起始地址的偏移量（offset）都是该成员类型大小的整数倍，这就可能造成内存空间的浪费，即前面提到的填充字节。
3. 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如果不足，会在结构体末尾添加填充字节。
4. 如果结构体中包含其他结构体或联合体，那么也需要按照这些内部结构体或联合体的对齐要求来对齐。

举例说明：

```
struct MyStruct {
    char a;        // 1字节
    int b;         // 4字节
    short c;       // 2字节
};
```

在上述结构体中，`int` 类型通常需要按照4字节对齐，在32位或64位架构下。假设编译器按照4字节对齐规则对该结构体进行内存对齐，则实际内存布局可能如下：

- `char a;` 占用1字节，后面跟着3字节的填充，以确保接下来的 `int b;` 能在4字节边界上对齐。
- `int b;` 直接按照4字节对齐，紧接着 `char a;` 后面的填充字节。
- `short c;` 占用2字节，并且因为已经处于4字节边界上，所以不需要额外填充。

结构体总大小：`sizeof(MyStruct)` 很可能是8个字节（1字节`char` + 3字节填充 + 4字节`int`），但实际上还有一个2字节的`short`，所以需要再加上2个字节的填充，使得整个结构体大小为12字节，满足最大对齐成员`int`的4字节的整数倍。

记住，具体的对齐情况取决于编译器设置（例如GCC的`__attribute__((packed))`、`#pragma pack`等）和目标平台的硬件架构。开发者可以通过这些手段来修改默认的对齐规则，以满足特定的内存或性能要求。