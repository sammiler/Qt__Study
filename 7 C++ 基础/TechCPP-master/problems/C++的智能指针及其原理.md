### 智能指针简介

C++的智能指针是一种用于管理动态分配内存的对象，它们提供了自动内存管理机制，避免了手动释放内存的繁琐和潜在的内存泄漏问题。

智能指针的原理基于RAII原则，即资源获取即初始化。智能指针通过在构造函数中获取资源（动态分配的内存），并在析构函数中释放资源，从而确保资源的正确释放。

C++标准库提供了两种主要的智能指针：`std::unique_ptr`和`std::shared_ptr`。

1. `std::unique_ptr`： `std::unique_ptr`是独占所有权的智能指针，它确保只有一个指针可以访问所管理的对象。当`std::unique_ptr`被销毁时，它会自动释放所拥有的对象。它不能被复制，但可以通过std::move()函数进行所有权转移。
2. `std::shared_ptr`： `std::shared_ptr`是共享所有权的智能指针，它可以被多个指针同时访问和共享所管理的对象。它使用引用计数来追踪有多少个指针指向该对象，当引用计数为0时，即没有任何指针指向对象时，资源会被释放。`std::shared_ptr`可以被复制和赋值。



注意：weak_ptr严格来说，不能算是“智能指针”，他只是一个类的弱引用，是用来解决两个`std::shared_ptr`相互进行引用的问题的



### 侵入式和非侵入式的智能指针

在C++中，智能指针又被分为两种:侵入式和非侵入式的

1. **侵入式智能指针**： 侵入式智能指针需要被管理的类提供特定的接口或继承指定的基类，以支持智能指针的操作。这意味着被管理的类必须拥有与智能指针相关的成员函数或遵循特定的约定。侵入式智能指针可以更好地控制资源的生命周期，但需要修改被管理类的定义。

   例如，Boost库中的`boost::intrusive_ptr`就是一种侵入式智能指针。被管理的类必须实现`add_ref()`和`release()`等函数，以增加和释放引用计数。

2. **非侵入式智能指针**： 非侵入式智能指针不需要被管理的类提供额外的接口或继承特定的基类。它通过自身的机制来管理资源的生命周期，而不需要对被管理的类做任何修改。这样可以更方便地将智能指针应用到已有的类中。

   C++标准库中的`std::shared_ptr`就是一种非侵入式智能指针。它可以管理任何动态分配的对象，而不需要对被管理的类做任何特殊要求。

非侵入式智能指针相对于侵入式智能指针更加灵活和方便，但在某些情况下侵入式智能指针可能提供更细粒度的资源管理控制。选择使用哪种类型的智能指针取决于具体的需求和设计考虑。