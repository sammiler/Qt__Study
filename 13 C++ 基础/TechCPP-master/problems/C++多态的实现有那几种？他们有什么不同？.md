C++中，多态性主要通过两种方式实现：编译时多态（静态多态）和运行时多态（动态多态）。这两种多态的机制、特点和用途有所不同。

1. **编译时多态（静态多态）**: 编译时多态是在程序编译阶段实现的多态性。主要通过函数重载和运算符重载来实现。

   - **函数重载**: 同一个作用域内存在多个同名函数，但它们的参数类型或数量不同。根据调用时实际传递的参数类型和数量，编译器决定调用哪个函数。
   - **运算符重载**: 允许定义或重新定义大部分C++内置的运算符，使得它们可以根据操作数的类型执行不同的操作。

   **编译时多态的决策是在编译时做出的**，因此它不支持在运行时根据对象的实际类型来选择相应的成员函数。

2. **运行时多态（动态多态）**: 运行时多态是在程序运行阶段实现的多态性。它主要通过虚函数和继承来实现。

   - **虚函数**: 通过在基类中声明虚函数，允许派生类中重写该函数。当通过基类的指针或引用调用虚函数时，实际执行的是与指针或引用所指对象的实际类型相对应的函数版本。
   - **抽象类和纯虚函数**: 抽象类至少包含一个纯虚函数。纯虚函数在基类中没有实现，派生类必须重写这个函数。抽象类不能被实例化。

   **运行时多态的决策是在程序运行时做出的**，这就**需要运行时类型信息和虚函数表（vtable）**。在运行时，根据对象的实际类型来动态调用相应的成员函数，从而实现多态。

总的来说：

- **编译时多态**是静态的，主要通过函数重载和运算符重载来实现，决策发生在编译阶段。
- **运行时多态**是动态的，需要虚函数机制，并且决策发生在程序运行时。
- **运行时多态**能够提供更高的灵活性和扩展性，是实现框架和库中一些高级功能（如插件架构或事件处理系统）的关键。
- **编译时多态**由于在编译期就已经确定了调用哪个函数，通常性能更高，因为它避免了运行时查找虚函数表的开销。