1. **成员顺序**: 结构体的成员变量在内存中按它们声明的顺序依次排列。
2. **数据对齐**: 为了提高访问速度，编译器会根据目标平台的要求对结构体成员进行对齐。这可能导致在成员之间或结构体末尾存在填充字节（padding）。
   - 对齐规则通常要求一个类型的数据地址必须是其大小的整数倍。例如，一个4字节的`int`通常需要放置在地址为4的倍数的位置上。
   - `#pragma pack`或编译器特定属性可用于改变或禁用默认的对齐行为。
3. **继承**: 如果结构体是从一个或多个其他结构体/类继承而来，则基类的成员将首先出现在派生类对象的内存中，后面跟着派生类自己的成员。
4. **虚函数**: 如果结构体有虚函数，编译器通常会在结构体的内存布局中加入一个指向虚函数表（vtable）的指针。这个指针位于对象的开始处，但具体位置取决于编译器的实现。
5. **虚继承**: 使用虚继承时，为了解决菱形继承问题，编译器会采取复杂的策略来安排内存布局，这通常涉及额外的指针和调整对象模型。
6. **静态成员**: 静态成员变量不作为结构体的一部分存储在每个对象的内存中，它们在全局/静态存储区有单独的存储空间。
7. **位域**: 如果结构体使用了位域，则相邻的位域可以被紧密打包以减少空间占用。但是，如果跨越了底层类型的边界，位域可能会被分割开。
8. **零大小数组**: 某些编译器允许在结构体末尾使用零大小数组作为柔性数组成员（flexible array member），而这通常不占用结构体的内存空间，只是作为一个符号占位符。